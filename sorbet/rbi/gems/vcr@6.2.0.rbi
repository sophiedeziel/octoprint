# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `vcr` gem.
# Please instead update this file by running `bin/tapioca gem vcr`.

# source://vcr//lib/vcr/util/logger.rb#1
module VCR
  include ::VCR::VariableArgsBlockCaller
  include ::VCR::Errors
  extend ::VCR::VariableArgsBlockCaller
  extend ::VCR::Errors
  extend ::VCR

  # source://vcr//lib/vcr.rb#385
  def cassette_persisters; end

  # source://vcr//lib/vcr.rb#380
  def cassette_serializers; end

  # source://vcr//lib/vcr.rb#362
  def cassettes(context = T.unsafe(nil)); end

  # source://vcr//lib/vcr/deprecations.rb#4
  def config; end

  # source://vcr//lib/vcr.rb#239
  def configuration; end

  # source://vcr//lib/vcr.rb#234
  def configure; end

  # source://vcr//lib/vcr.rb#256
  def cucumber_tags(&block); end

  # source://vcr//lib/vcr.rb#48
  def current_cassette; end

  # source://vcr//lib/vcr.rb#159
  def eject_cassette(options = T.unsafe(nil)); end

  # source://vcr//lib/vcr.rb#408
  def fibers_available?; end

  # source://vcr//lib/vcr.rb#345
  def http_interactions; end

  # source://vcr//lib/vcr.rb#132
  def insert_cassette(name, options = T.unsafe(nil)); end

  # source://vcr//lib/vcr.rb#375
  def library_hooks; end

  # source://vcr//lib/vcr.rb#398
  def link_context(from_thread, to_key); end

  # source://vcr//lib/vcr.rb#351
  def real_http_connections_allowed?; end

  # source://vcr//lib/vcr.rb#390
  def record_http_interaction(interaction); end

  # source://vcr//lib/vcr.rb#370
  def request_ignorer; end

  # source://vcr//lib/vcr.rb#357
  def request_matchers; end

  # source://vcr//lib/vcr.rb#290
  def turn_off!(options = T.unsafe(nil)); end

  # source://vcr//lib/vcr.rb#327
  def turn_on!; end

  # source://vcr//lib/vcr.rb#270
  def turned_off(options = T.unsafe(nil)); end

  # source://vcr//lib/vcr.rb#311
  def turned_on(options = T.unsafe(nil)); end

  # source://vcr//lib/vcr.rb#337
  def turned_on?; end

  # source://vcr//lib/vcr.rb#403
  def unlink_context(key); end

  # source://vcr//lib/vcr.rb#184
  def use_cassette(name, options = T.unsafe(nil), &block); end

  # source://vcr//lib/vcr.rb#213
  def use_cassettes(cassettes, &block); end

  # source://vcr//lib/vcr/version.rb#11
  def version; end

  private

  # source://vcr//lib/vcr.rb#448
  def context_cassettes; end

  # source://vcr//lib/vcr.rb#427
  def context_value(name); end

  # source://vcr//lib/vcr.rb#413
  def current_context; end

  # source://vcr//lib/vcr.rb#435
  def dup_context(context); end

  # source://vcr//lib/vcr.rb#417
  def get_context(thread_key, fiber_key = T.unsafe(nil)); end

  # source://vcr//lib/vcr.rb#444
  def ignore_cassettes?; end

  # source://vcr//lib/vcr.rb#452
  def initialize_fibers; end

  # source://vcr//lib/vcr.rb#461
  def initialize_ivars; end

  # source://vcr//lib/vcr.rb#431
  def set_context_value(name, value); end

  class << self
    # source://vcr//lib/vcr/deprecations.rb#10
    def const_missing(const); end
  end
end

# source://vcr//lib/vcr/cassette/http_interaction_list.rb#2
class VCR::Cassette
  include ::VCR::Logger::Mixin

  # source://vcr//lib/vcr/cassette.rb#58
  def initialize(name, options = T.unsafe(nil)); end

  # source://vcr//lib/vcr/cassette.rb#47
  def clean_outdated_http_interactions; end

  # source://vcr//lib/vcr/cassette.rb#50
  def drop_unused_requests; end

  # source://vcr//lib/vcr/cassette.rb#78
  def eject(options = T.unsafe(nil)); end

  # source://vcr//lib/vcr/cassette.rb#41
  def erb; end

  # source://vcr//lib/vcr/cassette.rb#132
  def file; end

  # source://vcr//lib/vcr/cassette.rb#102
  def http_interactions; end

  # source://vcr//lib/vcr/cassette.rb#171
  def linked?; end

  # source://vcr//lib/vcr/cassette.rb#36
  def match_requests_on; end

  # source://vcr//lib/vcr/cassette.rb#21
  def name; end

  # source://vcr//lib/vcr/cassette.rb#124
  def new_recorded_interactions; end

  # source://vcr//lib/vcr/cassette.rb#166
  def originally_recorded_at; end

  # source://vcr//lib/vcr/cassette.rb#44
  def re_record_interval; end

  # source://vcr//lib/vcr/cassette.rb#116
  def record_http_interaction(interaction); end

  # source://vcr//lib/vcr/cassette.rb#25
  def record_mode; end

  # source://vcr//lib/vcr/cassette.rb#32
  def record_on_error; end

  # source://vcr//lib/vcr/cassette.rb#140
  def recording?; end

  # source://vcr//lib/vcr/cassette.rb#87
  def run_failed!; end

  # source://vcr//lib/vcr/cassette.rb#92
  def run_failed?; end

  # source://vcr//lib/vcr/cassette.rb#149
  def serializable_hash; end

  # source://vcr//lib/vcr/cassette.rb#97
  def should_write_recorded_interactions_to_disk?; end

  # source://vcr//lib/vcr/cassette.rb#54
  def tags; end

  private

  # source://vcr//lib/vcr/cassette.rb#177
  def assert_valid_options!; end

  # source://vcr//lib/vcr/cassette.rb#205
  def assign_tags; end

  # source://vcr//lib/vcr/cassette.rb#324
  def deserialized_hash; end

  # source://vcr//lib/vcr/cassette.rb#191
  def extract_options; end

  # source://vcr//lib/vcr/cassette.rb#300
  def interactions_to_record; end

  # source://vcr//lib/vcr/cassette.rb#316
  def invoke_hook(type, interactions); end

  # source://vcr//lib/vcr/cassette.rb#337
  def log_prefix; end

  # source://vcr//lib/vcr/cassette.rb#278
  def merged_interactions; end

  # source://vcr//lib/vcr/cassette.rb#213
  def previously_recorded_interactions; end

  # source://vcr//lib/vcr/cassette.rb#231
  def raise_error_unless_valid_record_mode; end

  # source://vcr//lib/vcr/cassette.rb#274
  def raw_cassette_bytes; end

  # source://vcr//lib/vcr/cassette.rb#341
  def request_summary(request); end

  # source://vcr//lib/vcr/cassette.rb#270
  def should_assert_no_unused_interactions?; end

  # source://vcr//lib/vcr/cassette.rb#237
  def should_re_record?(record_mode); end

  # source://vcr//lib/vcr/cassette.rb#262
  def should_remove_matching_existing_interactions?; end

  # source://vcr//lib/vcr/cassette.rb#266
  def should_remove_unused_interactions?; end

  # source://vcr//lib/vcr/cassette.rb#258
  def should_stub_requests?; end

  # source://vcr//lib/vcr/cassette.rb#227
  def storage_key; end

  # source://vcr//lib/vcr/cassette.rb#295
  def up_to_date_interactions(interactions); end

  # source://vcr//lib/vcr/cassette.rb#308
  def write_recorded_interactions_to_disk; end

  class << self
    # source://vcr//lib/vcr/deprecations.rb#17
    def const_missing(const); end
  end
end

# source://vcr//lib/vcr/cassette/erb_renderer.rb#6
class VCR::Cassette::ERBRenderer
  # source://vcr//lib/vcr/cassette/erb_renderer.rb#7
  def initialize(raw_template, erb, cassette_name = T.unsafe(nil)); end

  # source://vcr//lib/vcr/cassette/erb_renderer.rb#11
  def render; end

  private

  # source://vcr//lib/vcr/cassette/erb_renderer.rb#52
  def binding_for_variables; end

  # source://vcr//lib/vcr/cassette/erb_renderer.rb#34
  def erb_variables; end

  # source://vcr//lib/vcr/cassette/erb_renderer.rb#21
  def handle_name_error(e); end

  # source://vcr//lib/vcr/cassette/erb_renderer.rb#38
  def template; end

  # source://vcr//lib/vcr/cassette/erb_renderer.rb#30
  def use_erb?; end

  # source://vcr//lib/vcr/cassette/erb_renderer.rb#48
  def variables_object; end
end

# source://vcr//lib/vcr/cassette/serializers.rb#49
module VCR::Cassette::EncodingErrorHandling
  # source://vcr//lib/vcr/cassette/serializers.rb#50
  def handle_encoding_errors; end
end

# source://vcr//lib/vcr/cassette/http_interaction_list.rb#4
class VCR::Cassette::HTTPInteractionList
  include ::VCR::Logger::Mixin

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#18
  def initialize(interactions, request_matchers, allow_playback_repeats = T.unsafe(nil), parent_list = T.unsafe(nil), log_prefix = T.unsafe(nil)); end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#16
  def allow_playback_repeats; end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#65
  def assert_no_unused_interactions!; end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#48
  def has_interaction_matching?(request); end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#54
  def has_used_interaction_matching?(request); end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#16
  def interactions; end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#16
  def parent_list; end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#58
  def remaining_unused_interaction_count; end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#16
  def request_matchers; end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#31
  def response_for(request); end

  private

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#79
  def has_unused_interactions?; end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#96
  def interaction_matches_request?(request, interaction); end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#107
  def log_prefix; end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#87
  def matching_interaction_index_for(request); end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#91
  def matching_used_interaction_for(request); end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#83
  def request_summary(request); end
end

# source://vcr//lib/vcr/cassette/http_interaction_list.rb#8
module VCR::Cassette::HTTPInteractionList::NullList
  extend ::VCR::Cassette::HTTPInteractionList::NullList

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#11
  def has_interaction_matching?(*a); end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#12
  def has_used_interaction_matching?(*a); end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#13
  def remaining_unused_interaction_count(*a); end

  # source://vcr//lib/vcr/cassette/http_interaction_list.rb#10
  def response_for(*a); end
end

# source://vcr//lib/vcr/cassette/persisters.rb#4
class VCR::Cassette::Persisters
  # source://vcr//lib/vcr/cassette/persisters.rb#8
  def initialize; end

  # source://vcr//lib/vcr/cassette/persisters.rb#17
  def [](name); end

  # source://vcr//lib/vcr/cassette/persisters.rb#31
  def []=(name, value); end
end

# source://vcr//lib/vcr/cassette/persisters/file_system.rb#7
module VCR::Cassette::Persisters::FileSystem
  extend ::VCR::Cassette::Persisters::FileSystem

  # source://vcr//lib/vcr/cassette/persisters/file_system.rb#23
  def [](file_name); end

  # source://vcr//lib/vcr/cassette/persisters/file_system.rb#33
  def []=(file_name, content); end

  # source://vcr//lib/vcr/cassette/persisters/file_system.rb#41
  def absolute_path_to_file(file_name); end

  # source://vcr//lib/vcr/cassette/persisters/file_system.rb#11
  def storage_location; end

  # source://vcr//lib/vcr/cassette/persisters/file_system.rb#14
  def storage_location=(dir); end

  private

  # source://vcr//lib/vcr/cassette/persisters/file_system.rb#47
  def absolute_path_for(path); end

  # source://vcr//lib/vcr/cassette/persisters/file_system.rb#63
  def downcase_cassette_names?; end

  # source://vcr//lib/vcr/cassette/persisters/file_system.rb#51
  def sanitized_file_name_from(file_name); end
end

# source://vcr//lib/vcr/cassette/serializers.rb#4
class VCR::Cassette::Serializers
  # source://vcr//lib/vcr/cassette/serializers.rb#12
  def initialize; end

  # source://vcr//lib/vcr/cassette/serializers.rb#21
  def [](name); end

  # source://vcr//lib/vcr/cassette/serializers.rb#39
  def []=(name, value); end
end

# source://vcr//lib/vcr/cassette/serializers/compressed.rb#15
module VCR::Cassette::Serializers::Compressed
  extend ::VCR::Cassette::Serializers::Compressed

  # source://vcr//lib/vcr/cassette/serializers/compressed.rb#38
  def deserialize(string); end

  # source://vcr//lib/vcr/cassette/serializers/compressed.rb#21
  def file_extension; end

  # source://vcr//lib/vcr/cassette/serializers/compressed.rb#29
  def serialize(hash); end
end

# source://vcr//lib/vcr/cassette/serializers/json.rb#11
module VCR::Cassette::Serializers::JSON
  extend ::VCR::Cassette::Serializers::JSON
  extend ::VCR::Cassette::EncodingErrorHandling
  extend ::VCR::Cassette::SyntaxErrorHandling

  # source://vcr//lib/vcr/cassette/serializers/json.rb#44
  def deserialize(string); end

  # source://vcr//lib/vcr/cassette/serializers/json.rb#26
  def file_extension; end

  # source://vcr//lib/vcr/cassette/serializers/json.rb#34
  def serialize(hash); end
end

# source://vcr//lib/vcr/cassette/serializers/json.rb#17
VCR::Cassette::Serializers::JSON::ENCODING_ERRORS = T.let(T.unsafe(nil), Array)

# source://vcr//lib/vcr/cassette/serializers/json.rb#21
VCR::Cassette::Serializers::JSON::SYNTAX_ERRORS = T.let(T.unsafe(nil), Array)

# source://vcr//lib/vcr/cassette/serializers/psych.rb#11
module VCR::Cassette::Serializers::Psych
  extend ::VCR::Cassette::Serializers::Psych
  extend ::VCR::Cassette::EncodingErrorHandling
  extend ::VCR::Cassette::SyntaxErrorHandling

  # source://vcr//lib/vcr/cassette/serializers/psych.rb#45
  def deserialize(string); end

  # source://vcr//lib/vcr/cassette/serializers/psych.rb#25
  def file_extension; end

  # source://vcr//lib/vcr/cassette/serializers/psych.rb#33
  def serialize(hash); end
end

# source://vcr//lib/vcr/cassette/serializers/psych.rb#17
VCR::Cassette::Serializers::Psych::ENCODING_ERRORS = T.let(T.unsafe(nil), Array)

# source://vcr//lib/vcr/cassette/serializers/psych.rb#20
VCR::Cassette::Serializers::Psych::SYNTAX_ERRORS = T.let(T.unsafe(nil), Array)

# source://vcr//lib/vcr/cassette/serializers/syck.rb#11
module VCR::Cassette::Serializers::Syck
  extend ::VCR::Cassette::Serializers::Syck
  extend ::VCR::Cassette::EncodingErrorHandling
  extend ::VCR::Cassette::SyntaxErrorHandling

  # source://vcr//lib/vcr/cassette/serializers/syck.rb#43
  def deserialize(string); end

  # source://vcr//lib/vcr/cassette/serializers/syck.rb#25
  def file_extension; end

  # source://vcr//lib/vcr/cassette/serializers/syck.rb#33
  def serialize(hash); end

  private

  # source://vcr//lib/vcr/cassette/serializers/syck.rb#53
  def using_syck; end
end

# source://vcr//lib/vcr/cassette/serializers/syck.rb#17
VCR::Cassette::Serializers::Syck::ENCODING_ERRORS = T.let(T.unsafe(nil), Array)

# source://vcr//lib/vcr/cassette/serializers/syck.rb#20
VCR::Cassette::Serializers::Syck::SYNTAX_ERRORS = T.let(T.unsafe(nil), Array)

# source://vcr//lib/vcr/cassette/serializers/yaml.rb#13
module VCR::Cassette::Serializers::YAML
  extend ::VCR::Cassette::Serializers::YAML
  extend ::VCR::Cassette::EncodingErrorHandling
  extend ::VCR::Cassette::SyntaxErrorHandling

  # source://vcr//lib/vcr/cassette/serializers/yaml.rb#47
  def deserialize(string); end

  # source://vcr//lib/vcr/cassette/serializers/yaml.rb#27
  def file_extension; end

  # source://vcr//lib/vcr/cassette/serializers/yaml.rb#35
  def serialize(hash); end
end

# source://vcr//lib/vcr/cassette/serializers/yaml.rb#19
VCR::Cassette::Serializers::YAML::ENCODING_ERRORS = T.let(T.unsafe(nil), Array)

# source://vcr//lib/vcr/cassette/serializers/yaml.rb#22
VCR::Cassette::Serializers::YAML::SYNTAX_ERRORS = T.let(T.unsafe(nil), Array)

# source://vcr//lib/vcr/cassette/serializers.rb#59
module VCR::Cassette::SyntaxErrorHandling
  # source://vcr//lib/vcr/cassette/serializers.rb#60
  def handle_syntax_errors; end
end

# source://vcr//lib/vcr/cassette.rb#17
VCR::Cassette::VALID_RECORD_MODES = T.let(T.unsafe(nil), Array)

# source://vcr//lib/vcr.rb#27
VCR::CassetteMutex = T.let(T.unsafe(nil), Thread::Mutex)

# source://vcr//lib/vcr/configuration.rb#7
class VCR::Configuration
  include ::VCR::VariableArgsBlockCaller
  include ::VCR::Hooks
  include ::VCR::Configuration::DefinedHooks
  include ::VCR::Logger::Mixin
  extend ::VCR::Hooks::ClassMethods

  # source://vcr//lib/vcr/configuration.rb#490
  def initialize; end

  # source://vcr//lib/vcr/configuration.rb#366
  def after_http_request(*filters); end

  # source://vcr//lib/vcr/configuration.rb#129
  def allow_http_connections_when_no_cassette=(_arg0); end

  # source://vcr//lib/vcr/configuration.rb#131
  def allow_http_connections_when_no_cassette?; end

  # source://vcr//lib/vcr/configuration.rb#395
  def around_http_request(*filters, &block); end

  # source://vcr//lib/vcr/configuration.rb#325
  def before_playback(tag = T.unsafe(nil), &block); end

  # source://vcr//lib/vcr/configuration.rb#297
  def before_record(tag = T.unsafe(nil), &block); end

  # source://vcr//lib/vcr/configuration.rb#15
  def cassette_library_dir; end

  # source://vcr//lib/vcr/configuration.rb#30
  def cassette_library_dir=(dir); end

  # source://vcr//lib/vcr/configuration.rb#269
  def cassette_persisters; end

  # source://vcr//lib/vcr/configuration.rb#253
  def cassette_serializers; end

  # source://vcr//lib/vcr/configuration.rb#418
  def configure_rspec_metadata!; end

  # source://vcr//lib/vcr/configuration.rb#440
  def debug_logger; end

  # source://vcr//lib/vcr/configuration.rb#442
  def debug_logger=(value); end

  # source://vcr//lib/vcr/configuration.rb#46
  def default_cassette_options; end

  # source://vcr//lib/vcr/configuration.rb#49
  def default_cassette_options=(overrides); end

  # source://vcr//lib/vcr/configuration.rb#225
  def define_cassette_placeholder(placeholder, tag = T.unsafe(nil), &block); end

  # source://vcr//lib/vcr/configuration.rb#225
  def filter_sensitive_data(placeholder, tag = T.unsafe(nil), &block); end

  # source://vcr//lib/vcr/configuration.rb#65
  def hook_into(*hooks); end

  # source://vcr//lib/vcr/configuration.rb#75
  def ignore_host(*hosts); end

  # source://vcr//lib/vcr/configuration.rb#75
  def ignore_hosts(*hosts); end

  # source://vcr//lib/vcr/configuration.rb#94
  def ignore_localhost=(value); end

  # source://vcr//lib/vcr/configuration.rb#112
  def ignore_request(&block); end

  # source://vcr//lib/vcr/configuration.rb#454
  def logger; end

  # source://vcr//lib/vcr/configuration.rb#484
  def preserve_exact_body_bytes_for?(http_message); end

  # source://vcr//lib/vcr/configuration.rb#151
  def query_parser; end

  # source://vcr//lib/vcr/configuration.rb#151
  def query_parser=(_arg0); end

  # source://vcr//lib/vcr/configuration.rb#198
  def register_request_matcher(name, &block); end

  # source://vcr//lib/vcr/deprecations.rb#26
  def stub_with(*adapters); end

  # source://vcr//lib/vcr/configuration.rb#84
  def unignore_host(*hosts); end

  # source://vcr//lib/vcr/configuration.rb#84
  def unignore_hosts(*hosts); end

  # source://vcr//lib/vcr/configuration.rb#177
  def uri_parser; end

  # source://vcr//lib/vcr/configuration.rb#177
  def uri_parser=(_arg0); end

  private

  # source://vcr//lib/vcr/configuration.rb#529
  def create_fiber_for(fiber_errors, hook_declaration, proc); end

  # source://vcr//lib/vcr/configuration.rb#511
  def load_library_hook(hook); end

  # source://vcr//lib/vcr/configuration.rb#582
  def log_prefix; end

  # source://vcr//lib/vcr/configuration.rb#564
  def register_built_in_hooks; end

  # source://vcr//lib/vcr/configuration.rb#559
  def request_filter_from(object); end

  # source://vcr//lib/vcr/configuration.rb#519
  def resume_fiber(fiber, fiber_errors, response, hook_declaration); end

  # source://vcr//lib/vcr/configuration.rb#548
  def start_new_fiber_for(request, fibers, fiber_errors, hook_declaration, proc); end

  # source://vcr//lib/vcr/configuration.rb#554
  def tag_filter_from(tag); end
end

# source://vcr//lib/vcr/configuration.rb#0
module VCR::Configuration::DefinedHooks
  # source://vcr//lib/vcr/util/hooks.rb#55
  def after_http_request(*filters, &hook); end

  # source://vcr//lib/vcr/util/hooks.rb#55
  def after_library_hooks_loaded(*filters, &hook); end

  # source://vcr//lib/vcr/util/hooks.rb#55
  def before_http_request(*filters, &hook); end

  # source://vcr//lib/vcr/util/hooks.rb#55
  def before_playback(*filters, &hook); end

  # source://vcr//lib/vcr/util/hooks.rb#55
  def before_record(*filters, &hook); end

  # source://vcr//lib/vcr/util/hooks.rb#55
  def preserve_exact_body_bytes(*filters, &hook); end
end

# source://vcr//lib/vcr/test_frameworks/cucumber.rb#3
class VCR::CucumberTags
  # source://vcr//lib/vcr/test_frameworks/cucumber.rb#19
  def initialize(main_object); end

  # source://vcr//lib/vcr/test_frameworks/cucumber.rb#30
  def tag(*tag_names); end

  # source://vcr//lib/vcr/test_frameworks/cucumber.rb#30
  def tags(*tag_names); end

  class << self
    # source://vcr//lib/vcr/test_frameworks/cucumber.rb#11
    def add_tag(tag); end

    # source://vcr//lib/vcr/test_frameworks/cucumber.rb#6
    def tags; end
  end
end

# source://vcr//lib/vcr/test_frameworks/cucumber.rb#84
class VCR::CucumberTags::ScenarioNameBuilder
  # source://vcr//lib/vcr/test_frameworks/cucumber.rb#85
  def initialize(test_case); end

  # source://vcr//lib/vcr/test_frameworks/cucumber.rb#90
  def cassette_name; end

  # source://vcr//lib/vcr/test_frameworks/cucumber.rb#100
  def examples_table(*_arg0); end

  # source://vcr//lib/vcr/test_frameworks/cucumber.rb#103
  def examples_table_row(row); end

  # source://vcr//lib/vcr/test_frameworks/cucumber.rb#94
  def feature(feature); end

  # source://vcr//lib/vcr/test_frameworks/cucumber.rb#100
  def scenario(*_arg0); end

  # source://vcr//lib/vcr/test_frameworks/cucumber.rb#94
  def scenario_outline(feature); end
end

# source://vcr//lib/vcr/deprecations.rb#33
module VCR::Deprecations; end

# source://vcr//lib/vcr/deprecations.rb#34
module VCR::Deprecations::Middleware; end

# source://vcr//lib/vcr/deprecations.rb#36
module VCR::Deprecations::Middleware::Faraday
  # source://vcr//lib/vcr/deprecations.rb#37
  def initialize(*args); end
end

# source://vcr//lib/vcr/errors.rb#3
module VCR::Errors; end

# source://vcr//lib/vcr/errors.rb#36
class VCR::Errors::AroundHTTPRequestHookError < ::VCR::Errors::Error; end

# source://vcr//lib/vcr/errors.rb#10
class VCR::Errors::CassetteInUseError < ::VCR::Errors::Error; end

# source://vcr//lib/vcr/errors.rb#56
class VCR::Errors::EjectLinkedCassetteError < ::VCR::Errors::Error; end

# source://vcr//lib/vcr/errors.rb#5
class VCR::Errors::Error < ::StandardError; end

# source://vcr//lib/vcr/errors.rb#32
class VCR::Errors::InvalidCassetteFormatError < ::VCR::Errors::Error; end

# source://vcr//lib/vcr/errors.rb#26
class VCR::Errors::LibraryVersionTooLowError < ::VCR::Errors::Error; end

# source://vcr//lib/vcr/errors.rb#21
class VCR::Errors::MissingERBVariableError < ::VCR::Errors::Error; end

# source://vcr//lib/vcr/errors.rb#41
class VCR::Errors::NotSupportedError < ::VCR::Errors::Error; end

# source://vcr//lib/vcr/errors.rb#15
class VCR::Errors::TurnedOffError < ::VCR::Errors::Error; end

# source://vcr//lib/vcr/errors.rb#64
class VCR::Errors::UnhandledHTTPRequestError < ::VCR::Errors::Error
  # source://vcr//lib/vcr/errors.rb#70
  def initialize(request); end

  # source://vcr//lib/vcr/errors.rb#65
  def request; end

  private

  # source://vcr//lib/vcr/errors.rb#136
  def cassettes_description; end

  # source://vcr//lib/vcr/errors.rb#148
  def cassettes_list; end

  # source://vcr//lib/vcr/errors.rb#81
  def construct_message; end

  # source://vcr//lib/vcr/errors.rb#90
  def current_cassettes; end

  # source://vcr//lib/vcr/errors.rb#118
  def current_matchers; end

  # source://vcr//lib/vcr/errors.rb#183
  def format_bullet_point(lines, index); end

  # source://vcr//lib/vcr/errors.rb#189
  def format_foot_note(url, index); end

  # source://vcr//lib/vcr/errors.rb#128
  def formatted_headers; end

  # source://vcr//lib/vcr/errors.rb#168
  def formatted_suggestions; end

  # source://vcr//lib/vcr/errors.rb#295
  def has_used_interaction_matching?; end

  # source://vcr//lib/vcr/errors.rb#114
  def match_request_on_body?; end

  # source://vcr//lib/vcr/errors.rb#110
  def match_request_on_headers?; end

  # source://vcr//lib/vcr/errors.rb#299
  def match_requests_on_suggestion; end

  # source://vcr//lib/vcr/errors.rb#277
  def no_cassette_suggestions; end

  # source://vcr//lib/vcr/errors.rb#283
  def record_mode_suggestion; end

  # source://vcr//lib/vcr/errors.rb#77
  def relish_version_slug; end

  # source://vcr//lib/vcr/errors.rb#94
  def request_description; end

  # source://vcr//lib/vcr/errors.rb#259
  def suggestion_for(key); end

  # source://vcr//lib/vcr/errors.rb#266
  def suggestions; end
end

# source://vcr//lib/vcr/errors.rb#194
VCR::Errors::UnhandledHTTPRequestError::ALL_SUGGESTIONS = T.let(T.unsafe(nil), Hash)

# source://vcr//lib/vcr/errors.rb#46
class VCR::Errors::UnknownContentEncodingError < ::VCR::Errors::Error; end

# source://vcr//lib/vcr/errors.rb#29
class VCR::Errors::UnregisteredMatcherError < ::VCR::Errors::Error; end

# source://vcr//lib/vcr/errors.rb#52
class VCR::Errors::UnusedHTTPInteractionError < ::VCR::Errors::Error; end

# source://vcr//lib/vcr/structs.rb#501
class VCR::HTTPInteraction < ::Struct
  # source://vcr//lib/vcr/structs.rb#502
  def initialize(*args); end

  # source://vcr//lib/vcr/structs.rb#532
  def hook_aware; end

  # source://vcr//lib/vcr/structs.rb#512
  def to_hash; end

  class << self
    # source://vcr//lib/vcr/structs.rb#524
    def from_hash(hash); end
  end
end

# source://vcr//lib/vcr/structs.rb#538
class VCR::HTTPInteraction::HookAware
  # source://vcr//lib/vcr/structs.rb#539
  def initialize(http_interaction); end

  # source://vcr//lib/vcr/structs.rb#563
  def filter!(text, replacement_text); end

  # source://vcr//lib/vcr/structs.rb#548
  def ignore!; end

  # source://vcr//lib/vcr/structs.rb#554
  def ignored?; end

  private

  # source://vcr//lib/vcr/structs.rb#584
  def filter_hash!(hash, text, replacement_text); end

  # source://vcr//lib/vcr/structs.rb#571
  def filter_object!(object, text, replacement_text); end
end

# source://vcr//lib/vcr/util/hooks.rb#5
module VCR::Hooks
  include ::VCR::VariableArgsBlockCaller

  mixes_in_class_methods ::VCR::Hooks::ClassMethods

  # source://vcr//lib/vcr/util/hooks.rb#34
  def clear_hooks; end

  # source://vcr//lib/vcr/util/hooks.rb#44
  def has_hooks_for?(hook_type); end

  # source://vcr//lib/vcr/util/hooks.rb#38
  def hooks; end

  # source://vcr//lib/vcr/util/hooks.rb#28
  def invoke_hook(hook_type, *args); end

  class << self
    # source://vcr//lib/vcr/util/hooks.rb#19
    def included(klass); end
  end
end

# source://vcr//lib/vcr/util/hooks.rb#49
module VCR::Hooks::ClassMethods
  # source://vcr//lib/vcr/util/hooks.rb#50
  def define_hook(hook_type, prepend = T.unsafe(nil)); end
end

# source://vcr//lib/vcr/util/hooks.rb#9
class VCR::Hooks::FilteredHook < ::Struct
  include ::VCR::VariableArgsBlockCaller

  # source://vcr//lib/vcr/util/hooks.rb#12
  def conditionally_invoke(*args); end

  def filters; end
  def filters=(_); end
  def hook; end
  def hook=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://vcr//lib/vcr/util/internet_connection.rb#26
module VCR::InternetConnection
  extend ::VCR::InternetConnection

  # source://vcr//lib/vcr/util/internet_connection.rb#31
  def available?; end
end

# source://vcr//lib/vcr/util/internet_connection.rb#29
VCR::InternetConnection::EXAMPLE_HOST = T.let(T.unsafe(nil), String)

# source://vcr//lib/vcr/library_hooks.rb#3
class VCR::LibraryHooks
  # source://vcr//lib/vcr/library_hooks.rb#6
  def disabled?(hook); end

  # source://vcr//lib/vcr/library_hooks.rb#4
  def exclusive_hook; end

  # source://vcr//lib/vcr/library_hooks.rb#4
  def exclusive_hook=(_arg0); end

  # source://vcr//lib/vcr/library_hooks.rb#10
  def exclusively_enabled(hook); end
end

# source://vcr//lib/vcr/linked_cassette.rb#7
class VCR::LinkedCassette < ::SimpleDelegator
  # source://vcr//lib/vcr/linked_cassette.rb#62
  def eject(*args); end

  # source://vcr//lib/vcr/linked_cassette.rb#68
  def linked?; end

  class << self
    # source://vcr//lib/vcr/linked_cassette.rb#57
    def list(cassettes, linked_cassettes); end
  end
end

# source://vcr//lib/vcr/linked_cassette.rb#8
class VCR::LinkedCassette::CassetteList
  include ::Enumerable

  # source://vcr//lib/vcr/linked_cassette.rb#14
  def initialize(cassettes, linked_cassettes); end

  # source://vcr//lib/vcr/linked_cassette.rb#20
  def each; end

  # source://vcr//lib/vcr/linked_cassette.rb#31
  def last; end

  # source://vcr//lib/vcr/linked_cassette.rb#40
  def size; end

  protected

  # source://vcr//lib/vcr/linked_cassette.rb#45
  def wrap(cassette); end
end

# source://vcr//lib/vcr/util/logger.rb#4
class VCR::Logger
  # source://vcr//lib/vcr/util/logger.rb#5
  def initialize(stream); end

  # source://vcr//lib/vcr/util/logger.rb#9
  def log(message, log_prefix, indentation_level = T.unsafe(nil)); end

  # source://vcr//lib/vcr/util/logger.rb#15
  def request_summary(request, request_matchers); end

  # source://vcr//lib/vcr/util/logger.rb#22
  def response_summary(response); end
end

# source://vcr//lib/vcr/util/logger.rb#45
module VCR::Logger::Mixin
  # source://vcr//lib/vcr/util/logger.rb#46
  def log(message, indentation_level = T.unsafe(nil)); end

  # source://vcr//lib/vcr/util/logger.rb#50
  def request_summary(*args); end

  # source://vcr//lib/vcr/util/logger.rb#54
  def response_summary(*args); end
end

# source://vcr//lib/vcr/util/logger.rb#34
module VCR::Logger::Null
  private

  # source://vcr//lib/vcr/util/logger.rb#37
  def log(*_arg0); end

  # source://vcr//lib/vcr/util/logger.rb#38
  def request_summary(*_arg0); end

  # source://vcr//lib/vcr/util/logger.rb#39
  def response_summary(*_arg0); end

  class << self
    # source://vcr//lib/vcr/util/logger.rb#37
    def log(*_arg0); end

    # source://vcr//lib/vcr/util/logger.rb#38
    def request_summary(*_arg0); end

    # source://vcr//lib/vcr/util/logger.rb#39
    def response_summary(*_arg0); end
  end
end

# source://vcr//lib/vcr.rb#30
VCR::MainThread = T.let(T.unsafe(nil), Thread)

# source://vcr//lib/vcr.rb#39
module VCR::Middleware; end

# source://vcr//lib/vcr/middleware/rack.rb#5
class VCR::Middleware::CassetteArguments
  # source://vcr//lib/vcr/middleware/rack.rb#7
  def initialize; end

  # source://vcr//lib/vcr/middleware/rack.rb#16
  def name(name = T.unsafe(nil)); end

  # source://vcr//lib/vcr/middleware/rack.rb#25
  def options(options = T.unsafe(nil)); end
end

# source://vcr//lib/vcr/middleware/faraday.rb#15
class VCR::Middleware::Faraday
  include ::VCR::Deprecations::Middleware::Faraday

  # source://vcr//lib/vcr/middleware/faraday.rb#21
  def initialize(app); end

  # source://vcr//lib/vcr/middleware/faraday.rb#29
  def call(env); end

  # source://vcr//lib/vcr/middleware/faraday.rb#35
  def close; end
end

# source://vcr//lib/vcr/middleware/faraday.rb#40
class VCR::Middleware::Faraday::RequestHandler < ::VCR::RequestHandler
  # source://vcr//lib/vcr/middleware/faraday.rb#42
  def initialize(app, env); end

  # source://vcr//lib/vcr/middleware/faraday.rb#41
  def app; end

  # source://vcr//lib/vcr/middleware/faraday.rb#41
  def env; end

  # source://vcr//lib/vcr/middleware/faraday.rb#47
  def handle; end

  private

  # source://vcr//lib/vcr/middleware/faraday.rb#129
  def collect_chunks; end

  # source://vcr//lib/vcr/middleware/faraday.rb#61
  def delay_finishing?; end

  # source://vcr//lib/vcr/middleware/faraday.rb#124
  def invoke_after_request_hook(response); end

  # source://vcr//lib/vcr/middleware/faraday.rb#94
  def on_ignored_request; end

  # source://vcr//lib/vcr/middleware/faraday.rb#113
  def on_recordable_request; end

  # source://vcr//lib/vcr/middleware/faraday.rb#100
  def on_stubbed_by_vcr_request; end

  # source://vcr//lib/vcr/middleware/faraday.rb#73
  def raw_body_from(body); end

  # source://vcr//lib/vcr/middleware/faraday.rb#81
  def response_for(response); end

  # source://vcr//lib/vcr/middleware/faraday.rb#139
  def restore_body_from_chunks(request); end

  # source://vcr//lib/vcr/middleware/faraday.rb#65
  def vcr_request; end
end

# source://vcr//lib/vcr/middleware/rack.rb#43
class VCR::Middleware::Rack
  include ::VCR::VariableArgsBlockCaller

  # source://vcr//lib/vcr/middleware/rack.rb#53
  def initialize(app, &block); end

  # source://vcr//lib/vcr/middleware/rack.rb#62
  def call(env); end

  private

  # source://vcr//lib/vcr/middleware/rack.rb#72
  def cassette_arguments(env); end
end

# source://vcr//lib/vcr/structs.rb#7
module VCR::Normalizers; end

# source://vcr//lib/vcr/structs.rb#9
module VCR::Normalizers::Body
  mixes_in_class_methods ::VCR::Normalizers::Body::ClassMethods

  # source://vcr//lib/vcr/structs.rb#61
  def initialize(*args); end

  private

  # source://vcr//lib/vcr/structs.rb#92
  def base_body_hash(body); end

  # source://vcr//lib/vcr/structs.rb#78
  def serializable_body; end

  class << self
    # source://vcr//lib/vcr/structs.rb#10
    def included(klass); end
  end
end

# source://vcr//lib/vcr/structs.rb#15
module VCR::Normalizers::Body::ClassMethods
  # source://vcr//lib/vcr/structs.rb#16
  def body_from(hash_or_string); end

  # source://vcr//lib/vcr/structs.rb#29
  def force_encode_string(string, encoding); end

  # source://vcr//lib/vcr/structs.rb#34
  def try_encode_string(string, encoding); end
end

# source://vcr//lib/vcr/structs.rb#103
module VCR::Normalizers::Header
  # source://vcr//lib/vcr/structs.rb#104
  def initialize(*args); end

  private

  # source://vcr//lib/vcr/structs.rb#153
  def convert_to_raw_strings(array); end

  # source://vcr//lib/vcr/structs.rb#146
  def delete_header(key); end

  # source://vcr//lib/vcr/structs.rb#139
  def edit_header(key, value = T.unsafe(nil)); end

  # source://vcr//lib/vcr/structs.rb#134
  def get_header(key); end

  # source://vcr//lib/vcr/structs.rb#129
  def header_key(key); end

  # source://vcr//lib/vcr/structs.rb#111
  def normalize_headers; end
end

# source://vcr//lib/vcr/util/internet_connection.rb#8
module VCR::Ping
  private

  # source://vcr//lib/vcr/util/internet_connection.rb#9
  def pingecho(host, timeout = T.unsafe(nil), service = T.unsafe(nil)); end

  class << self
    # source://vcr//lib/vcr/util/internet_connection.rb#9
    def pingecho(host, timeout = T.unsafe(nil), service = T.unsafe(nil)); end
  end
end

# source://vcr//lib/vcr.rb#35
module VCR::RSpec; end

# source://vcr//lib/vcr/test_frameworks/rspec.rb#5
module VCR::RSpec::Metadata
  extend ::VCR::RSpec::Metadata

  # source://vcr//lib/vcr/test_frameworks/rspec.rb#30
  def configure!; end

  # source://vcr//lib/vcr/test_frameworks/rspec.rb#8
  def vcr_cassette_name_for(metadata); end
end

# source://vcr//lib/vcr/structs.rb#176
class VCR::Request < ::Struct
  include ::VCR::Normalizers::Header
  include ::VCR::Normalizers::Body
  extend ::VCR::Normalizers::Body::ClassMethods

  # source://vcr//lib/vcr/structs.rb#180
  def initialize(*args); end

  # source://vcr//lib/vcr/structs.rb#228
  def method(*args); end

  # source://vcr//lib/vcr/structs.rb#223
  def parsed_uri; end

  # source://vcr//lib/vcr/structs.rb#197
  def to_hash; end

  private

  # source://vcr//lib/vcr/structs.rb#315
  def without_standard_port(uri); end

  class << self
    # source://vcr//lib/vcr/structs.rb#210
    def from_hash(hash); end
  end
end

# source://vcr//lib/vcr/structs.rb#296
class VCR::Request::FiberAware
  # source://vcr//lib/vcr/structs.rb#297
  def proceed; end

  # source://vcr//lib/vcr/structs.rb#306
  def to_proc; end
end

# source://vcr//lib/vcr/structs.rb#235
class VCR::Request::Typed
  # source://vcr//lib/vcr/structs.rb#240
  def initialize(request, type); end

  # source://vcr//lib/vcr/structs.rb#261
  def externally_stubbed?; end

  # source://vcr//lib/vcr/structs.rb#246
  def ignored?; end

  # source://vcr//lib/vcr/structs.rb#277
  def real?; end

  # source://vcr//lib/vcr/structs.rb#266
  def recordable?; end

  # source://vcr//lib/vcr/structs.rb#285
  def stubbed?; end

  # source://vcr//lib/vcr/structs.rb#253
  def stubbed_by_vcr?; end

  # source://vcr//lib/vcr/structs.rb#236
  def type; end

  # source://vcr//lib/vcr/structs.rb#271
  def unhandled?; end
end

# source://vcr//lib/vcr/request_handler.rb#3
class VCR::RequestHandler
  include ::VCR::Logger::Mixin

  # source://vcr//lib/vcr/request_handler.rb#6
  def handle; end

  private

  # source://vcr//lib/vcr/request_handler.rb#62
  def disabled?; end

  # source://vcr//lib/vcr/request_handler.rb#54
  def externally_stubbed?; end

  # source://vcr//lib/vcr/request_handler.rb#66
  def has_response_stub?(consume_stub); end

  # source://vcr//lib/vcr/request_handler.rb#49
  def invoke_after_request_hook(vcr_response); end

  # source://vcr//lib/vcr/request_handler.rb#43
  def invoke_before_request_hook; end

  # source://vcr//lib/vcr/request_handler.rb#78
  def library_name; end

  # source://vcr//lib/vcr/request_handler.rb#110
  def log_prefix; end

  # source://vcr//lib/vcr/request_handler.rb#84
  def on_externally_stubbed_request; end

  # source://vcr//lib/vcr/request_handler.rb#87
  def on_ignored_request; end

  # source://vcr//lib/vcr/request_handler.rb#93
  def on_recordable_request; end

  # source://vcr//lib/vcr/request_handler.rb#90
  def on_stubbed_by_vcr_request; end

  # source://vcr//lib/vcr/request_handler.rb#96
  def on_unhandled_request; end

  # source://vcr//lib/vcr/request_handler.rb#100
  def request_summary; end

  # source://vcr//lib/vcr/request_handler.rb#33
  def request_type(consume_stub = T.unsafe(nil)); end

  # source://vcr//lib/vcr/request_handler.rb#29
  def set_typed_request_for_after_hook(request_type); end

  # source://vcr//lib/vcr/request_handler.rb#58
  def should_ignore?; end

  # source://vcr//lib/vcr/request_handler.rb#74
  def stubbed_response; end
end

# source://vcr//lib/vcr/request_ignorer.rb#6
class VCR::RequestIgnorer
  include ::VCR::VariableArgsBlockCaller
  include ::VCR::Hooks
  include ::VCR::RequestIgnorer::DefinedHooks
  extend ::VCR::Hooks::ClassMethods

  # source://vcr//lib/vcr/request_ignorer.rb#13
  def initialize; end

  # source://vcr//lib/vcr/request_ignorer.rb#40
  def ignore?(request); end

  # source://vcr//lib/vcr/request_ignorer.rb#32
  def ignore_hosts(*hosts); end

  # source://vcr//lib/vcr/request_ignorer.rb#20
  def ignore_localhost=(value); end

  # source://vcr//lib/vcr/request_ignorer.rb#28
  def localhost_ignored?; end

  # source://vcr//lib/vcr/request_ignorer.rb#36
  def unignore_hosts(*hosts); end

  private

  # source://vcr//lib/vcr/request_ignorer.rb#46
  def ignored_hosts; end
end

# source://vcr//lib/vcr/request_ignorer.rb#0
module VCR::RequestIgnorer::DefinedHooks
  # source://vcr//lib/vcr/util/hooks.rb#55
  def ignore_request(*filters, &hook); end
end

# source://vcr//lib/vcr/request_ignorer.rb#11
VCR::RequestIgnorer::LOCALHOST_ALIASES = T.let(T.unsafe(nil), Array)

# source://vcr//lib/vcr/request_matcher_registry.rb#5
class VCR::RequestMatcherRegistry
  # source://vcr//lib/vcr/request_matcher_registry.rb#49
  def initialize; end

  # source://vcr//lib/vcr/request_matcher_registry.rb#64
  def [](matcher); end

  # source://vcr//lib/vcr/request_matcher_registry.rb#55
  def register(name, &block); end

  # source://vcr//lib/vcr/request_matcher_registry.rb#91
  def uri_without_param(*ignores); end

  # source://vcr//lib/vcr/request_matcher_registry.rb#91
  def uri_without_params(*ignores); end

  private

  # source://vcr//lib/vcr/request_matcher_registry.rb#105
  def raise_unregistered_matcher_error(name); end

  # source://vcr//lib/vcr/request_matcher_registry.rb#111
  def register_built_ins; end

  # source://vcr//lib/vcr/request_matcher_registry.rb#132
  def try_to_register_body_as_json; end

  # source://vcr//lib/vcr/request_matcher_registry.rb#98
  def uri_without_param_matchers; end
end

# source://vcr//lib/vcr/request_matcher_registry.rb#9
VCR::RequestMatcherRegistry::DEFAULT_MATCHERS = T.let(T.unsafe(nil), Array)

# source://vcr//lib/vcr/request_matcher_registry.rb#12
class VCR::RequestMatcherRegistry::Matcher < ::Struct
  # source://vcr//lib/vcr/request_matcher_registry.rb#13
  def matches?(request_1, request_2); end
end

# source://vcr//lib/vcr/request_matcher_registry.rb#19
class VCR::RequestMatcherRegistry::URIWithoutParamsMatcher < ::Struct
  # source://vcr//lib/vcr/request_matcher_registry.rb#39
  def call(request_1, request_2); end

  # source://vcr//lib/vcr/request_matcher_registry.rb#20
  def partial_uri_from(request); end

  # source://vcr//lib/vcr/request_matcher_registry.rb#43
  def to_proc; end
end

# source://vcr//lib/vcr/structs.rb#331
class VCR::Response < ::Struct
  include ::VCR::Normalizers::Header
  include ::VCR::Normalizers::Body
  extend ::VCR::Normalizers::Body::ClassMethods

  # source://vcr//lib/vcr/structs.rb#335
  def initialize(*args); end

  # source://vcr//lib/vcr/structs.rb#382
  def compressed?; end

  # source://vcr//lib/vcr/structs.rb#377
  def content_encoding; end

  # source://vcr//lib/vcr/structs.rb#396
  def decompress; end

  # source://vcr//lib/vcr/structs.rb#410
  def recompress; end

  # source://vcr//lib/vcr/structs.rb#345
  def to_hash; end

  # source://vcr//lib/vcr/structs.rb#370
  def update_content_length_header; end

  # source://vcr//lib/vcr/structs.rb#387
  def vcr_decompressed?; end

  class << self
    # source://vcr//lib/vcr/structs.rb#449
    def decompress(body, type); end

    # source://vcr//lib/vcr/structs.rb#360
    def from_hash(hash); end
  end
end

# source://vcr//lib/vcr/structs.rb#440
VCR::Response::HAVE_ZLIB = T.let(T.unsafe(nil), TrueClass)

# source://vcr//lib/vcr/structs.rb#480
class VCR::ResponseStatus < ::Struct
  # source://vcr//lib/vcr/structs.rb#481
  def to_hash; end

  class << self
    # source://vcr//lib/vcr/structs.rb#491
    def from_hash(hash); end
  end
end

# source://vcr//lib/vcr/util/variable_args_block_caller.rb#3
module VCR::VariableArgsBlockCaller
  # source://vcr//lib/vcr/util/variable_args_block_caller.rb#4
  def call_block(block, *args); end
end

# source://vcr//lib/vcr/util/version_checker.rb#3
class VCR::VersionChecker
  # source://vcr//lib/vcr/util/version_checker.rb#4
  def initialize(library_name, library_version, min_version); end

  # source://vcr//lib/vcr/util/version_checker.rb#13
  def check_version!; end

  private

  # source://vcr//lib/vcr/util/version_checker.rb#29
  def compare_version; end

  # source://vcr//lib/vcr/util/version_checker.rb#43
  def parse_version(version); end

  # source://vcr//lib/vcr/util/version_checker.rb#23
  def raise_too_low_error; end

  # source://vcr//lib/vcr/util/version_checker.rb#19
  def too_low?; end

  # source://vcr//lib/vcr/util/version_checker.rb#39
  def version_requirement; end
end
